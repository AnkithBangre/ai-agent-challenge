"""
ICICI Bank Statement Parser
Auto-generated by Agent-as-Coder

This parser extracts transaction data from ICICI bank statement PDFs.
"""

import re
from typing import List, Dict
import pandas as pd
import pdfplumber


def parse(pdf_path: str) -> pd.DataFrame:
    """
    Parse ICICI bank statement PDF and extract transactions.
    
    Args:
        pdf_path: Path to the ICICI bank statement PDF file
        
    Returns:
        DataFrame with columns: Date, Description, Withdrawal, Deposit, Balance
        
    Raises:
        FileNotFoundError: If PDF file doesn't exist
        ValueError: If PDF format is invalid or no transactions found
    """
    try:
        with pdfplumber.open(pdf_path) as pdf:
            transactions = []
            
            for page in pdf.pages:
                # Extract text and tables
                text = page.extract_text()
                tables = page.extract_tables()
                
                # Parse transactions from tables
                for table in tables:
                    if not table:
                        continue
                    
                    # Identify header row
                    header_idx = _find_header_row(table)
                    if header_idx is None:
                        continue
                    
                    # Process transaction rows
                    for row in table[header_idx + 1:]:
                        transaction = _parse_transaction_row(row)
                        if transaction:
                            transactions.append(transaction)
            
            if not transactions:
                raise ValueError("No transactions found in PDF")
            
            # Create DataFrame
            df = pd.DataFrame(transactions)
            
            # Clean and format data
            df = _clean_dataframe(df)
            
            return df
            
    except FileNotFoundError:
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    except Exception as e:
        raise ValueError(f"Error parsing PDF: {str(e)}")


def _find_header_row(table: List[List[str]]) -> int:
    """
    Find the header row in a table by looking for key column names.
    
    Args:
        table: List of rows from PDF table
        
    Returns:
        Index of header row, or None if not found
    """
    header_keywords = ['date', 'description', 'withdrawal', 'deposit', 'balance']
    
    for idx, row in enumerate(table):
        if not row:
            continue
        
        row_text = ' '.join(str(cell).lower() for cell in row if cell)
        
        # Check if row contains most header keywords
        matches = sum(1 for keyword in header_keywords if keyword in row_text)
        if matches >= 3:
            return idx
    
    return None


def _parse_transaction_row(row: List[str]) -> Dict[str, str]:
    """
    Parse a single transaction row from the table.
    
    Args:
        row: List of cell values from table row
        
    Returns:
        Dictionary with transaction data, or None if row is invalid
    """
    if not row or len(row) < 4:
        return None
    
    # Filter out empty cells
    cells = [cell for cell in row if cell and str(cell).strip()]
    
    if len(cells) < 3:
        return None
    
    # Basic validation: first cell should look like a date
    date_pattern = r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}'
    if not re.search(date_pattern, str(cells[0])):
        return None
    
    # Extract transaction data
    # Format: [Date, Description, Withdrawal/Deposit, Balance]
    transaction = {
        'Date': cells[0].strip(),
        'Description': cells[1].strip() if len(cells) > 1 else '',
        'Withdrawal': '',
        'Deposit': '',
        'Balance': ''
    }
    
    # Parse amounts (handle various formats)
    amount_cells = cells[2:]
    for cell in amount_cells:
        cell_str = str(cell).strip()
        
        # Skip non-numeric cells
        if not re.search(r'\d', cell_str):
            continue
        
        # Clean amount (remove commas, currency symbols)
        amount = _clean_amount(cell_str)
        
        # Determine if withdrawal or deposit based on context
        # (This logic may need adjustment based on actual statement format)
        if 'dr' in cell_str.lower() or amount < 0:
            transaction['Withdrawal'] = abs(amount)
        elif 'cr' in cell_str.lower():
            transaction['Deposit'] = amount
        elif not transaction['Balance']:
            transaction['Balance'] = amount
    
    return transaction


def _clean_amount(amount_str: str) -> float:
    """
    Clean and convert amount string to float.
    
    Args:
        amount_str: Amount string (may contain commas, currency symbols)
        
    Returns:
        Float value of amount
    """
    # Remove currency symbols, commas, and extra spaces
    cleaned = re.sub(r'[â‚¹$,\s]', '', amount_str)
    
    # Handle CR/DR notation
    is_negative = 'dr' in amount_str.lower()
    cleaned = re.sub(r'[a-zA-Z]', '', cleaned)
    
    try:
        value = float(cleaned)
        return -value if is_negative else value
    except ValueError:
        return 0.0


def _clean_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Clean and format the DataFrame.
    
    Args:
        df: Raw DataFrame with transaction data
        
    Returns:
        Cleaned DataFrame
    """
    # Convert date strings to datetime
    df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y', errors='coerce')
    
    # Convert amount columns to numeric
    amount_columns = ['Withdrawal', 'Deposit', 'Balance']
    for col in amount_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    
    # Sort by date
    df = df.sort_values('Date').reset_index(drop=True)
    
    # Remove rows with invalid dates
    df = df.dropna(subset=['Date'])
    
    return df


if __name__ == "__main__":
    # Test the parser
    import sys
    
    if len(sys.argv) > 1:
        pdf_path = sys.argv[1]
        result = parse(pdf_path)
        print(result)
    else:
        print("Usage: python icici_parser.py <path_to_pdf>")
